use std::{
    collections::HashMap,
    path::{Path, PathBuf},
};

use regex::Regex;

// This script copies it's own project (with necessary modifications, 
// e.g. without the build.rs itself) to the root of target directory 
// (on the same level as debug and release directories)
// and builds it with separate cargo session unrelated to the current one.
//
// The expected result of this execution is a bunch of error messages
// carrying information about alignment and sizes of strucutes in question.
//
// More detailed logic:
//
//  Project structure:
//
//  The `zenoh-ffi-opaque-types` sources plays double role. As a dependency for
//  the `zenoh-ffi` library it provides repr-C types for corresponding
//  Rust types. These types are auto generated by the build.rs and included
//  in the `lib.rs` of the `zenoh-ffi-opaque-types` crate.
//
//  The purpose of source file `src/probe.rs` is to calculate
//  the size and alignment of the opaque types. To do this it is compiled
//  by "cargo build" in the separate directory by the build.rs.
//  I.e. in the `zenoh-ffi-opaque-types` project itself the file `src/probe.rs`
//  plays only dummy role and included to it for simplifying development.
//
//  Build.rs algorithm
//
//  I. probe project preparation
//
//  To avoid unncessary rebuilds, in the steps below do not update destination
//  files if their contents would not change as a result of the operation.
//
//  1. create directories `opaque-types/probe` in the target directory
//     (4-level up from OUT_DIR)
//  2. create file Cargo.toml in the `opaque-types` directory which
//     will serve as local workspace
//  3. copy project's Cargo.toml to the `probe` directory
//  4. copy src/probe.rs to the `probe` directory with the name lib.rs
//  5. copy Cargo.lock file to `opaque-types` directory. The path to
//     Cargo.lock must be available in CARGO_LOCK environment variable.
//     Panic if variable not found
//
//  II. cargo build execution
//
//  Cargo build for `probe` can be executed once or twice, depending if the cross-compilation
//  is required. When zenoh-ffi-opaque-types is built as a dependency for
//  build.rs of the destination project, it's TARGET is a host platform. But
//  the destination project itself may be being built for a different target.
//  To provide the information about this target the variable CROSS_TARGET
//  must be set manually. E.g.
//  CROSS_TARGET=x86_64-unknown-linux-gnu cargo build --target x86_64-unknown-linux-gnu
//  It's also possible that the linker is different for the target platform.
//  The variable CROSS_RUSTC_LINKER must be set manually also in this case.
//
//  Steps:
// 
//  1. get target from TARGET variable
//  2. get linker from RUSTC_LINKER variable if present
//  3. Do the cargo build, store output for TARGET
//  4. if CROSS_TARGET variable is present and different from TARGET
//  4.1 get target from CROSS_TARGET variable
//  4.2 get linker from CROSS_RUSTC_LINKER variable if present
//  4.3 Do the cargo build, store output for CROSS_TARGET
//  5. return the outputs for both targets
//
//  Cargo build steps:
//
//  1. create features cargo argument. Uses `concat_enabled_features!` macro
//     from zenoh. Enable "panic" feature
//  2. create target cargo argument from target parameter
//  3. create linker cargo argument from linker parameter if present
//  4. run cargo build with the arguments, return output
//
//  III. analysis
//
//  1. For each target cargo output
//  1.1. parse cargo output, parse error messages with size/align reports
//  1.2. panic if cargo error detected.
//  1.3. panic if no rust errors detected
//  1.4. panic if total count of errors differs from count of reports collected
//  1.5. return size/alignment data for the target

//  IIII. generation
//
//  For each structure in the size/alignment data write to the output file
//  the elements below. More detailed information is in the existing code itself
//
//  1. declare repr-C structure with alignment attribute
//  2. inside the structure the byte array of size elements
//  3 structure is prepended with #prebindgen macro with cfg= attribute
//       restricting this structure for the specified target
//  4. if the structure not owned, add derive Copy, Clone
//  5. if the structure is owned, add the corresponding "moved" structure
//  6. for the "moved" structure implement TakeCType trait
//  7. for the owned structure implement Drop trait

pub fn main() {
    // Step I: probe project preparation
    println!("cargo:rerun-if-env-changed=CARGO_LOCK");
    println!("cargo:rerun-if-env-changed=OPAQUE_TYPES_BUILD_DIR");
    println!("cargo:rerun-if-changed=src/probe.rs");
    println!("cargo:rerun-if-changed=Cargo.toml");

    prepare_probe_project();
}

pub fn get_out_opaque_types() -> std::path::PathBuf {
    match std::env::var("OPAQUE_TYPES_BUILD_DIR") {
        Ok(opaque_types_build_dir) => {
            println!(
                "cargo:warning=OPAQUE_TYPES_BUILD_DIR = {}",
                opaque_types_build_dir
            );
            opaque_types_build_dir.into()
        }
        Err(_) => get_target_dir().join("opaque-types"),
    }
}

fn get_target_dir() -> std::path::PathBuf {
    // OUT_DIR typically looks like: target/<profile>/build/<crate-hash>/out
    // We need to go 4 levels up to reach the target directory root
    let mut p = get_out_dir();
    for _ in 0..4 {
        p = p
            .parent()
            .unwrap_or_else(|| panic!("Invalid OUT_DIR, cannot get target dir from {}", get_out_dir().display()))
            .to_path_buf();
    }
    p
}

fn prepare_probe_project() {
    // Create target/opaque-types/probe structure
    let opaque_root = get_out_opaque_types();
    let probe_dir = opaque_root.join("probe");
    let probe_src_dir = probe_dir.join("src");
    std::fs::create_dir_all(&probe_src_dir).expect("Failed to create probe/src directory");

    // 1) Workspace Cargo.toml at opaque-types/
    let workspace_manifest = opaque_root.join("Cargo.toml");
    let workspace_toml = "[workspace]\nresolver = \"2\"\nmembers = [\n    \"probe\"\n]\n";
    let _ = write_if_changed(&workspace_manifest, workspace_toml.as_bytes())
        .expect("Failed to write workspace Cargo.toml");

    // 2) Copy project's Cargo.toml into probe/
    let manifest_dir = std::env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR is not set");
    let project_manifest = std::path::Path::new(&manifest_dir).join("Cargo.toml");
    let probe_manifest = probe_dir.join("Cargo.toml");
    copy_file_if_changed(&project_manifest, &probe_manifest)
        .unwrap_or_else(|e| panic!("Failed to copy project Cargo.toml: {e}"));

    // 3) Copy src/probe.rs to probe/src/lib.rs
    let src_probe = std::path::Path::new(&manifest_dir).join("src/probe.rs");
    let dst_lib = probe_src_dir.join("lib.rs");
    copy_file_if_changed(&src_probe, &dst_lib)
        .unwrap_or_else(|e| panic!("Failed to copy src/probe.rs to probe/src/lib.rs: {e}"));

    // 4) Copy Cargo.lock to opaque-types/ from CARGO_LOCK env var
    let cargo_lock_path = std::env::var("CARGO_LOCK")
        .unwrap_or_else(|_| panic!("CARGO_LOCK environment variable must be set to the path of Cargo.lock"));
    let cargo_lock_src = std::path::PathBuf::from(cargo_lock_path);
    let cargo_lock_dst = opaque_root.join("Cargo.lock");
    copy_file_if_changed(&cargo_lock_src, &cargo_lock_dst)
        .unwrap_or_else(|e| panic!("Failed to copy Cargo.lock: {e}"));
}

fn write_if_changed(path: &Path, content: &[u8]) -> std::io::Result<bool> {
    use std::io::Read;
    let mut needs_write = true;
    if let Ok(mut f) = std::fs::File::open(path) {
        let mut existing = Vec::new();
        if f.read_to_end(&mut existing).is_ok() && existing == content {
            needs_write = false;
        }
    }
    if needs_write {
        if let Some(parent) = path.parent() {
            std::fs::create_dir_all(parent)?;
        }
        std::fs::write(path, content)?;
    }
    Ok(needs_write)
}

fn copy_file_if_changed(src: &Path, dst: &Path) -> std::io::Result<bool> {
    let content = std::fs::read(src)?;
    write_if_changed(dst, &content)
}

// Copy manifest and lock files to output directory, modify manifest to point to original source
fn copy_cargo_files_to_out_dir(cargo_lock_path: &Path) -> PathBuf {
    let out_dir = get_out_opaque_types();
    let source_dir = get_build_rs_path().join("./build-resources/opaque-types");
    let source_manifest = source_dir.join("Cargo.toml");
    std::fs::create_dir_all(&out_dir).unwrap();

    let dest_manifest = out_dir.join("Cargo.toml");

    // Read original manifest and modify it to use absolute path for source
    let mut manifest_content = std::fs::read_to_string(&source_manifest)
        .unwrap_or_else(|_| panic!("Failed to read manifest from {}", source_manifest.display()));

    // Add [lib] section with absolute path to original source
    let lib_path = source_dir
        .join("src/lib.rs")
        .canonicalize()
        .unwrap_or_else(|_| {
            panic!(
                "Failed to canonicalize path {}",
                source_dir.join("src/lib.rs").display()
            )
        });
    let lib_section = format!("\n[lib]\npath = \"{}\"\n", lib_path.display());
    manifest_content.push_str(&lib_section);

    std::fs::write(&dest_manifest, manifest_content)
        .unwrap_or_else(|_| panic!("Failed to write manifest to {}", dest_manifest.display()));

    let dest_lock = out_dir.join("Cargo.lock");
    std::fs::copy(&cargo_lock_path, &dest_lock).unwrap_or_else(|_| {
        panic!(
            "Failed to copy Cargo.lock from {} to {}",
            cargo_lock_path.display(),
            dest_lock.display()
        )
    });

    dest_manifest
}

pub fn generate_opaque_types(path_out: &Path, target: &str, cargo_lock_path: &Path) {
    let type_to_inner_field_name = HashMap::from([("z_id_t", "pub id")]);
    let manifest_path = copy_cargo_files_to_out_dir(cargo_lock_path);
    let (command, path_in) = produce_opaque_types_data(&manifest_path, target);

    let data_in = std::fs::read_to_string(path_in).unwrap();
    // check if message begins with "error:", excluding spaces
    if data_in.trim_start().starts_with("error:") {
        panic!(
            "Failed to generate opaque types due to cargo error:\n\nCommand executed:\n\n{command}\n\nCargo output:\n\n{data_in}"
        );
    }
    let mut data_out = String::new();
    let mut docs = get_opaque_type_docs();

    // Count the total number of errors in the input data
    let total_error_count = data_in
        .lines()
        .filter(|line| line.starts_with("error[E"))
        .count();

    // Scan for type size and layout information which is generated as compilation errors
    let mut good_error_count = 0;
    let re = Regex::new(r"type: (\w+), align: (\d+), size: (\d+)").unwrap();
    for (_, [type_name, align, size]) in re.captures_iter(&data_in).map(|c| c.extract()) {
        good_error_count += 1;
        let inner_field_name = type_to_inner_field_name.get(type_name).unwrap_or(&"_0");
        let (prefix, category, semantic, postfix) = split_type_name(type_name);
        let prebindgen_attr = "#[prebindgen(\"types\")]\n";
        let mut s = prebindgen_attr.to_string();
        if category != Some("owned") {
            s += "#[derive(Copy, Clone)]\n";
        };
        s += format!(
            "#[repr(C, align({align}))]
#[rustfmt::skip]
pub struct {type_name} {{
    {inner_field_name}: [u8; {size}],
}}
"
        )
        .as_str();
        if category == Some("owned") {
            let moved_type_name = format!("{}_{}_{}_{}", prefix, "moved", semantic, postfix);
            s += prebindgen_attr;
            s += format!(
                "#[repr(C)]
#[rustfmt::skip]
pub struct {moved_type_name} {{
    _this: {type_name},
}}
"
            )
            .as_str();

            s += format!(
                    "#[rustfmt::skip]
impl crate::transmute::TakeCType for {moved_type_name} {{
    type CType = {type_name};
    fn take_c_type(&mut self) -> Self::CType {{
        use crate::transmute::Gravestone;
        std::mem::replace(&mut self._this, {type_name}::gravestone())
    }}
}}

#[rustfmt::skip]
impl Drop for {type_name} {{
    fn drop(&mut self) {{
        use crate::transmute::{{RustTypeRef, Gravestone, IntoRustType}};
        let _ = std::mem::replace(self.as_rust_type_mut(), {type_name}::gravestone().into_rust_type());
    }}
}}
"
                )
                .as_str();
        }

        let doc = docs
            .remove(type_name)
            .unwrap_or_else(|| panic!("Failed to extract docs for opaque type: {type_name}"));
        for d in doc {
            data_out += &d;
            data_out += "\r\n";
        }
        data_out += &s;
    }

    if good_error_count == 0 {
        panic!(
            "Failed to generate opaque types: no valid type information found in the input data\n\nCommand executed:\n\n{command}\n\nCompiler output:\n\n{data_in}"
        );
    }

    if good_error_count != total_error_count {
        panic!(
            "Failed to generate opaque types: there are {total_error_count} errors in the input data, but only {good_error_count} of them were processed as information about opaque types\n\nCommand executed:\n\n{command}\n\nCompiler output:\n\n{data_in}"
        );
    }

    use std::io::Write;
    let mut file = std::fs::OpenOptions::new()
        .create(true)
        .append(false)
        .write(true)
        .open(path_out)
        .unwrap();
    file.write_all(data_out.as_bytes()).unwrap();
}

fn produce_opaque_types_data(manifest_path: &Path, target: &str) -> (String, PathBuf) {
    let linker = std::env::var("RUSTC_LINKER").unwrap_or_default();
    let output_file_path = get_out_opaque_types()
        .join(target)
        .join("build_resources_opaque_types.txt");
    std::fs::create_dir_all(output_file_path.parent().unwrap()).unwrap();
    let out_file = std::fs::File::create(output_file_path.clone()).unwrap();
    let stdio = std::process::Stdio::from(out_file);

    let mut linker_args = Vec::<String>::new();
    if !linker.is_empty() {
        linker_args.push("--config".to_string());
        linker_args.push(format!("target.{target}.linker=\"{linker}\""));
    }
    #[allow(unused_mut)]
    let mut feature_args: Vec<&str> = vec!["-F", "panic"];
    for feature in features().iter().filter(|f| !f.is_empty()) {
        feature_args.push("-F");
        feature_args.push(feature);
    }

    let mut command = std::process::Command::new("cargo");
    command
        .arg("build")
        .args(feature_args)
        .args(linker_args)
        .arg("--target")
        .arg(target)
        .arg("--manifest-path")
        .arg(manifest_path)
        .arg("--target-dir")
        .arg(get_out_opaque_types());
    let command_str = format!("{command:?}");
    let _ = command.stderr(stdio).output().unwrap();
    (command_str, output_file_path)
}

fn get_opaque_type_docs() -> HashMap<String, Vec<String>> {
    let current_folder = get_build_rs_path();
    let path_in = current_folder.join("./build-resources/opaque-types/src/lib.rs");
    let re = Regex::new(r"(?m)^get_opaque_type_data!\(\s*(.*)\s*,\s*(\w+)\s*(,)?\s*\);").unwrap();
    let mut comments = Vec::new();
    let mut opaque_lines = Vec::new();
    let mut res = HashMap::new();
    for line in std::fs::read_to_string(&path_in)
        .unwrap_or_else(|_| panic!("failed to read file {}", path_in.display()))
        .lines()
    {
        if line.starts_with("///") {
            comments.push(line.to_string());
            continue;
        }
        if line.starts_with("get_opaque_type_data!(") || !opaque_lines.is_empty() {
            opaque_lines.push(line);
        }
        if !opaque_lines.is_empty() && line.ends_with(");") {
            let joined_lines = std::mem::take(&mut opaque_lines).join("");
            let capture = re.captures(&joined_lines).expect("invalid opaque type");
            res.insert(capture[2].to_string(), std::mem::take(&mut comments));
        }
    }
    res
}

use std::collections::BTreeSet;

pub fn split_type_name(type_name: &str) -> (&str, Option<&str>, &str, &str) {
    let mut split = type_name.split('_');
    let prefix = split
        .next()
        .unwrap_or_else(|| panic!("Fist '_' not found in type name: {type_name}"));
    let cat = split
        .next()
        .unwrap_or_else(|| panic!("Second '_' not found in type name: {type_name}"));
    let category = if cat != "owned" && cat != "loaned" && cat != "moved" {
        None
    } else {
        Some(cat)
    };
    let postfix = split.next_back().expect("Type should end with '_t'");
    let prefix_cat_len = prefix.len() + 1 + category.map(|c| c.len() + 1).unwrap_or(0);
    let semantic = &type_name[prefix_cat_len..type_name.len() - postfix.len() - 1];
    (prefix, category, semantic, postfix)
}

pub fn features() -> BTreeSet<&'static str> {
    zenoh::FEATURES.split(" zenoh/").collect()
}

pub fn get_build_rs_path() -> std::path::PathBuf {
    let file_path = file!();
    let mut path_buf = std::path::PathBuf::new();
    path_buf.push(file_path);
    path_buf.parent().unwrap().to_path_buf()
}

pub fn get_out_dir() -> std::path::PathBuf {
    let out_dir = std::env::var_os("OUT_DIR").unwrap();
    std::path::Path::new(&out_dir).to_path_buf()
}

