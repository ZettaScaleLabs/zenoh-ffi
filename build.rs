use std::{env, path::Path};

use crate::buildrs::opaque_types_generator::generate_opaque_types;
mod buildrs;

pub fn get_build_rs_path() -> std::path::PathBuf {
    let file_path = file!();
    let mut path_buf = std::path::PathBuf::new();
    path_buf.push(file_path);
    path_buf.parent().unwrap().to_path_buf()
}

pub fn get_out_dir() -> std::path::PathBuf {
    let out_dir = env::var_os("OUT_DIR").unwrap();
    std::path::Path::new(&out_dir).to_path_buf()
}

fn main() {
    // Generate the platform-specific types.
    let path_out = get_out_dir().join("opaque_types.rs");
    let target = std::env::var("TARGET").unwrap();
    let cargo_lock= std::env::var("CARGO_LOCK").unwrap_or_else(|_| {
        panic!(
            "CARGO_LOCK environment variable is not defined. \n\n\
            zenoh-ffi needs the absolute path to Cargo.lock file of the project it's built with to\n\
            guarantee that size and alignment of generated C structures match the original Rust types. \n\n\
            Please set CARGO_LOCK to the absolute path of your project's Cargo.lock file, e.g:\n\n\
            CARGO_LOCK=$PWD/Cargo.lock cargo build\n"
        )
    });

    let cargo_lock = Path::new(&cargo_lock);
    if !cargo_lock.is_absolute() {
        panic!(
            "CARGO_LOCK must contain an absolute path, but got: {}\n\n\
            Please provide the absolute path to your project's Cargo.lock file.",
            cargo_lock.display()
        );
    }
    generate_opaque_types(&path_out, &target, cargo_lock);
    prebindgen::trace!(
        "Generated opaque types for TARGET={} : {}",
        target,
        path_out.display()
    );

    // Initialize the directory for collecting API (elements marked with `#[prebindgen]`)
    prebindgen::init_prebindgen_out_dir();
    // The recommended way to provide directory with data generated by `#[prebindgen]` is to set
    // the `PREBINDGEN_OUT_DIR` constant in the crate and use this constant in build.rs of downstream crates.
    // But for complex projects with code generation, like zenoh-ffi, this approach doesn't work well.
    // So in our case the e.g. zenoh-c executes build of zenoh-ffi from it's build.rs, passing
    // correct target and cargo lock path to it and reads `PREBINDGEN_OUT_DIR` value from the output
    prebindgen::trace!(
        "PREBINDGEN_OUT_DIR={}",
        prebindgen::get_prebindgen_out_dir().display()
    );

    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=buildrs");
    println!("cargo:rerun-if-changed=src");
    println!("cargo:rerun-if-changed=build-resources");
}
